#!/usr/bin/env bash
#
# A simple file browser for a local wiki. Uses `fzf` for selection and
# opens files in VISUAL > EDITOR priority order.

set -euo pipefail

# --- Configuration ---
wiki_path="${WIKI_DIR:-$HOME/Documents/wiki}"
recent_days="${WIKI_RECENT_DAYS:-30}"
preview_lines="${WIKI_PREVIEW_LINES:-20}"

# Files to exclude (can be overridden with WIKI_EXCLUDE_PATTERNS)
default_exclude_patterns=(
  '*.tmp'
  '*.swp'
  '*.lock'
  'package-lock.json'
  'yarn.lock'
  'Gemfile.lock'
  '*.log'
  '*.cache'
  'node_modules/*'
  '.DS_Store'
  '*.pyc'
  '__pycache__/*'
)

# Allow custom exclusions via environment variable
exclude_patterns=("${default_exclude_patterns[@]}")
if [[ -n "${WIKI_EXCLUDE_PATTERNS:-}" ]]; then
  IFS=' ' read -ra custom_patterns <<< "$WIKI_EXCLUDE_PATTERNS"
  exclude_patterns+=("${custom_patterns[@]}")
fi

# --- Helper Functions ---

# Function to find the best available editor
find_editor() {
  local editors=("${VISUAL:-}" "${EDITOR:-}" "code" "vim" "nvim" "subl" "micro")
  for ed in "${editors[@]}"; do
    if command -v "$ed" &> /dev/null; then
      echo "$ed"
      return 0
    fi
  done
  # Fallback to system default file opener
  if [[ "$(uname)" == "Darwin" ]]; then
    echo "open"
  else
    echo "xdg-open"
  fi
  return 0
}

# Function to open file with line number support
open_file_with_line() {
  local file="$1"
  local line="${2:-}"
  local editor="$3"

  if [[ -z "$editor" ]]; then
    echo "Error: No editor found."
    exit 1
  fi

  if [[ -n "$line" ]]; then
    case "$editor" in
      code|code-insiders)
        "$editor" -g "$file:$line"
        ;;
      subl|sublime_text)
        "$editor" "$file:$line"
        ;;
      vim|nvim|gvim)
        "$editor" "$file" "+$line"
        ;;
      open) # macOS
        open "$file"
        ;;
      xdg-open) # Linux
        xdg-open "$file"
        ;;
      *)
        # Fallback for other editors or if flags are not supported
        "$editor" "$file" "+$line" || "$editor" "$file"
        ;;
    esac
  else
    "$editor" "$file"
  fi
}

# Function to check for required tools
check_dependencies() {
  local missing=()
  for cmd in "fzf" "git" "rg"; do
    if ! command -v "$cmd" &> /dev/null; then
      missing+=("$cmd")
    fi
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Error: Missing required commands: ${missing[*]}" >&2
    exit 1
  fi
}

# --- Main Script Logic ---
check_dependencies

# Handle help command
if [[ "${1:-}" == "--help" ]]; then
  cat <<EOF
Usage: wiki [search_query | recent | --help]

Browse and search wiki content from: $wiki_path
You can override this path by setting the WIKI_DIR environment variable.

Modes:
  wiki              # Browse all files
  wiki "query"      # Search content and files
  wiki recent       # Show recently modified files
  --help            # Show this help message

Environment Variables:
  WIKI_DIR          Wiki directory path (default: ~/Documents/wiki)
  WIKI_RECENT_DAYS  Days to look back for recent files (default: 30)
  WIKI_EXCLUDE_PATTERNS  Space-separated patterns to exclude (e.g., "*.md *.txt")
  WIKI_PREVIEW_LINES Number of lines to show in previews (default: 20)
  VISUAL or EDITOR  Specify preferred editor (e.g., VISUAL=vim)

Dependencies:
  - fzf
  - ripgrep (rg)
  - git

Examples:
  wiki              # Start browsing all files
  wiki "topic"      # Search for "topic"
  wiki recent       # Show recent files
  WIKI_DIR=/path/to/my/wiki wiki # Use a different wiki path
EOF
  exit 0
fi

cd "$wiki_path" || {
  echo "Error: Cannot enter wiki directory: $wiki_path"
  exit 1
}

editor=$(find_editor)

initial_query="${1:-}"

# Define the fzf preview command once for clarity and reuse
# This logic checks if the file is binary and displays a preview if it's text.
fzf_preview_cmd="
  # Check if file is text/binary using multiple methods
  file_path=\"{}\"

  # First check by file extension for common text formats
  if [[ \"\$file_path\" =~ \\.(md|txt|rst|org|adoc|tex|log|conf|cfg|ini|json|yaml|yml|xml|html|css|js|ts|py|rb|sh|bash|zsh|fish|sql|diff|patch)$ ]]; then
    # Known text file extensions - show preview
    head -n \"$preview_lines\" \"\$file_path\"
  elif file --mime-type \"\$file_path\" 2>/dev/null | grep -q 'text/'; then
    # File command says it's text - show preview
    head -n \"$preview_lines\" \"\$file_path\"
  elif file \"\$file_path\" 2>/dev/null | grep -q 'text'; then
    # File command says it's text (without mime-type) - show preview
    head -n \"$preview_lines\" \"\$file_path\"
  else
    # Try to read first few bytes to see if it looks like text
    if head -c 1024 \"\$file_path\" 2>/dev/null | grep -q '^[[:print:][:space:]]*$'; then
      # Looks like text - show preview
      head -n \"$preview_lines\" \"\$file_path\"
    else
      # Probably binary - show message
      echo 'Binary file - no preview available'
    fi
  fi
"

# --- Recent Files Mode ---
if [[ "$initial_query" == "recent" ]]; then
  echo "Finding recently modified files (last $recent_days days)..."

  # Use git log for recent files, which is more reliable than find
  readarray -t recent_files < <(git log --name-only --pretty=format: --since="$recent_days days ago" --diff-filter=ACMR 2>/dev/null | grep -v '^$' | sort | uniq | head -20)

  if [[ ${#recent_files[@]} -eq 0 ]]; then
    echo "No recent files found in the last $recent_days days."
    exit 0
  fi

  selected=$(printf '%s\n' "${recent_files[@]}" | fzf --ansi --layout=reverse --border --height=40% --preview-window 'right:50%' --preview "$fzf_preview_cmd")

  if [[ -n "$selected" ]]; then
    echo "Opening $selected in $editor"
    open_file_with_line "$selected" "$editor"
  fi
  exit 0
fi

# --- Search Mode ---
if [[ -n "$initial_query" ]]; then
  echo "Searching for '$initial_query'..."

  # Build ripgrep exclude patterns
  rg_glob_patterns=()
  for p in "${exclude_patterns[@]}"; do
    rg_glob_patterns+=("--glob=!$p")
  done

  # Search both file names and content using rg with optimized flags
  search_results=$(rg --color=always --line-number --no-heading --with-filename --smart-case --hidden "${rg_glob_patterns[@]}" "$initial_query" 2>/dev/null || true)

  if [[ -z "$search_results" ]]; then
    echo "No results found for '$initial_query'"
    echo "Press Enter to browse all files instead..."
    read -r
    # Fall through to file browser mode
  else
    selected=$(echo "$search_results" | fzf --ansi --layout=reverse --border --height=40% --preview-window 'right:50%' --preview "
      # Extract file and line using awk for robustness
      file=\$(echo {} | awk -F: '{print \$1}')
      line=\$(echo {} | awk -F: '{print \$2}')

      # Use ripgrep for context preview, respecting line numbers
      if [[ -f \"\$file\" ]]; then
        # Check if file is text using multiple methods
        if [[ \"\$file\" =~ \\.md\$ ]] || [[ \"\$file\" =~ \\.txt\$ ]] || [[ \"\$file\" =~ \\.rst\$ ]] || [[ \"\$file\" =~ \\.org\$ ]] || [[ \"\$file\" =~ \\.adoc\$ ]] || [[ \"\$file\" =~ \\.tex\$ ]] || [[ \"\$file\" =~ \\.log\$ ]] || [[ \"\$file\" =~ \\.conf\$ ]] || [[ \"\$file\" =~ \\.cfg\$ ]] || [[ \"\$file\" =~ \\.ini\$ ]] || [[ \"\$file\" =~ \\.json\$ ]] || [[ \"\$file\" =~ \\.yaml\$ ]] || [[ \"\$file\" =~ \\.yml\$ ]] || [[ \"\$file\" =~ \\.xml\$ ]] || [[ \"\$file\" =~ \\.html\$ ]] || [[ \"\$file\" =~ \\.css\$ ]] || [[ \"\$file\" =~ \\.js\$ ]] || [[ \"\$file\" =~ \\.ts\$ ]] || [[ \"\$file\" =~ \\.py\$ ]] || [[ \"\$file\" =~ \\.rb\$ ]] || [[ \"\$file\" =~ \\.sh\$ ]] || [[ \"\$file\" =~ \\.bash\$ ]] || [[ \"\$file\" =~ \\.zsh\$ ]] || [[ \"\$file\" =~ \\.fish\$ ]] || [[ \"\$file\" =~ \\.sql\$ ]] || [[ \"\$file\" =~ \\.diff\$ ]] || [[ \"\$file\" =~ \\.patch\$ ]]; then
          # Known text file extensions - show preview
          rg --color=always --line-number --no-heading --context 3 --smart-case -A 3 -B 3 \"$initial_query\" \"\$file\" | sed \"s/^\$line-/<highlight>\$line-<\\/highlight>/\"
        elif file --mime-type \"\$file\" 2>/dev/null | grep -q \"text/\"; then
          # File command says it's text - show preview
          rg --color=always --line-number --no-heading --context 3 --smart-case -A 3 -B 3 \"$initial_query\" \"\$file\" | sed \"s/^\$line-/<highlight>\$line-<\\/highlight>/\"
        elif file \"\$file\" 2>/dev/null | grep -q \"text\"; then
          # File command says it's text (without mime-type) - show preview
          rg --color=always --line-number --no-heading --context 3 --smart-case -A 3 -B 3 \"$initial_query\" \"\$file\" | sed \"s/^\$line-/<highlight>\$line-<\\/highlight>/\"
        else
          # Try to read first few bytes to see if it looks like text
          if head -c 1024 \"\$file\" 2>/dev/null | grep -q \"^[[:print:][:space:]]*\$\"; then
            # Looks like text - show preview
            rg --color=always --line-number --no-heading --context 3 --smart-case -A 3 -B 3 \"$initial_query\" \"\$file\" | sed \"s/^\$line-/<highlight>\$line-<\\/highlight>/\"
          else
            echo \"Binary file - no preview available\"
          fi
        fi
      else
        echo \"File not found: \$file\"
      fi
    ")

    if [[ -n "$selected" ]]; then
      # Robustly extract filename and line number
      file=$(echo "$selected" | awk -F: '{print $1}')
      line=$(echo "$selected" | awk -F: '{print $2}')

      echo "Opening $file at line $line in $editor"
      open_file_with_line "$file" "$line" "$editor"
    fi
    exit 0
  fi
fi

# --- Default: Show All Files Mode ---
echo "Browsing all wiki files..."

# Build a regex pattern from the exclusion list for a single, fast grep
if [[ ${#exclude_patterns[@]} -gt 0 ]]; then
  exclude_regex=$(IFS=\|; echo "${exclude_patterns[*]}" | sed 's/\./\\./g; s/\*/.*/g')
else
  exclude_regex="a^" # A pattern that will never match anything
fi

# Use git ls-files for speed and .gitignore support, then filter with grep
selected=$(git ls-files 2>/dev/null | grep -vE "$exclude_regex" | sort | \
  fzf --ansi --layout=reverse --border --height=40% \
    --query "$initial_query" \
    --preview-window 'right:50%' \
    --preview "$fzf_preview_cmd")

# Handle file selection
if [[ -n "$selected" ]]; then
  echo "Opening $selected in $editor"
  open_file_with_line "$selected" "" "$editor"
fi
